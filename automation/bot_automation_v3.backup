#!/usr/bin/env python3
"""
v4.0 - –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø –°–ö–û–†–û–°–¢–¨
- –£–±—Ä–∞–Ω–∞ –∑–∞–¥–µ—Ä–∂–∫–∞ 0.15s
- –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –ø–æ–º–µ—Ç–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ —Ñ—É–Ω–∫—Ü–∏—é
- –£–º–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ edit
"""

import os
import asyncio
import logging
from typing import Optional, List
from datetime import datetime
from dotenv import load_dotenv
from telethon import TelegramClient, events
from telethon.tl.custom import Message
from telethon.tl.types import KeyboardButtonCallback, ReplyInlineMarkup
from telethon.tl import functions
from config import CONFIG

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=getattr(logging, CONFIG.get('LOG_LEVEL', 'INFO'))
)
logger = logging.getLogger(__name__)
logging.getLogger('telethon').setLevel(logging.WARNING)

load_dotenv()

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
PHONE_NUMBER = os.getenv('PHONE_NUMBER')
BOT_USERNAME = os.getenv('BOT_USERNAME')
SESSION_NAME = os.getenv('SESSION_NAME', 'telegram_session')
TRIGGER_MESSAGE = "–ü–æ—è–≤–∏–ª–∏—Å—å –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–≤–æ–∑–∫–∏"

class TransportBookingBot:
    def __init__(self):
        self.client = None
        self.bot_entity = None
        self.last_keyboard = None
        self.last_message_id = None
        self.is_processing = False
        self.automation_state = None
        self.automation_start_time = None
        self.last_processed_state_msg = None
        self.stats = {
            'triggers_detected': 0,
            'buttons_clicked': 0,
            'errors': 0,
            'start_time': datetime.now()
        }

    async def initialize(self):
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –∫–ª–∏–µ–Ω—Ç–∞...")
        if not API_ID or not API_HASH:
            raise ValueError("API_ID –∏ API_HASH –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–∫–∞–∑–∞–Ω—ã")
        self.client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
        await self.client.start(phone=PHONE_NUMBER)
        logger.info("–£—Å–ø–µ—à–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ")
        if BOT_USERNAME:
            try:
                self.bot_entity = await self.client.get_entity(BOT_USERNAME)
                logger.info(f"–ü–æ–¥–∫–ª—é—á–µ–Ω –∫ –±–æ—Ç—É: {BOT_USERNAME}")
            except Exception as e:
                logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –±–æ—Ç–∞: {e}")

    async def save_keyboard(self, message: Message):
        if message.reply_markup and isinstance(message.reply_markup, ReplyInlineMarkup):
            self.last_keyboard = message.reply_markup
            self.last_message_id = message.id
            if CONFIG.get('LOG_BUTTONS', True):
                logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å {len(message.reply_markup.rows)} —Ä—è–¥–∞–º–∏")
                for row_idx, row in enumerate(message.reply_markup.rows):
                    buttons_text = [btn.text for btn in row.buttons if hasattr(btn, 'text')]
                    logger.debug(f"  –†—è–¥ {row_idx + 1}: {buttons_text}")

    async def click_button(self, button: KeyboardButtonCallback, button_info: str = "") -> bool:
        if not self.last_message_id:
            logger.warning("–ù–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è")
            return False
        try:
            logger.info(f"‚ö° –ù–∞–∂–∞—Ç–∏–µ: '{button.text}' {button_info}")
            await self.client(
                functions.messages.GetBotCallbackAnswerRequest(
                    peer=self.bot_entity,
                    msg_id=self.last_message_id,
                    data=button.data
                )
            )
            logger.info(f"‚úì –ö–Ω–æ–ø–∫–∞ '{button.text}' –Ω–∞–∂–∞—Ç–∞")
            self.stats['buttons_clicked'] += 1
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            self.stats['errors'] += 1
            return False

    async def click_buttons_by_strategy(self) -> bool:
        if not self.last_keyboard:
            return False
        strategy = CONFIG.get('BUTTON_STRATEGY', 'first')
        try:
            if strategy == 'first':
                for row_idx, row in enumerate(self.last_keyboard.rows):
                    for button in row.buttons:
                        if isinstance(button, KeyboardButtonCallback):
                            return await self.click_button(button, f"(–ø–µ—Ä–≤–∞—è, —Ä—è–¥ {row_idx + 1})")
            return False
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
            return False

    async def continue_automation(self, message: Message):
        # –ö–†–ò–¢–ò–ß–ù–û: –ü–æ–º–µ—á–∞–µ–º –ù–ï–ú–ï–î–õ–ï–ù–ù–û –ø—Ä–∏ –≤—Ö–æ–¥–µ!
        state_msg_key = f"{message.id}_{self.automation_state}"
        if self.last_processed_state_msg == state_msg_key:
            logger.debug(f"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º: {state_msg_key}")
            return
        
        # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –ø–æ–º–µ—á–∞–µ–º
        self.last_processed_state_msg = state_msg_key
        
        logger.info(f"üîÑ {self.automation_state}, msg:{message.id}")
        
        # –¢–∞–π–º–∞—É—Ç
        if self.automation_start_time:
            elapsed = (datetime.now() - self.automation_start_time).total_seconds()
            if elapsed > 10.0:
                logger.warning("‚è±Ô∏è –¢–∞–π–º–∞—É—Ç")
                self.automation_state = None
                return

        try:
            if self.automation_state == 'waiting_list':
                logger.info("üìã –ò—â—É –ø–µ—Ä–µ–≤–æ–∑–∫—É...")
                
                if self.last_keyboard and len(self.last_keyboard.rows) > 0:
                    # –ò—â–µ–º –∫–Ω–æ–ø–∫—É –ø–µ—Ä–µ–≤–æ–∑–∫–∏
                    for row in self.last_keyboard.rows:
                        for button in row.buttons:
                            if isinstance(button, KeyboardButtonCallback):
                                if 'üöõ' in button.text:
                                    logger.info(f"‚ö° –ü–µ—Ä–µ–≤–æ–∑–∫–∞: '{button.text}'")
                                    success = await self.click_button(button, "(–ø–µ—Ä–µ–≤–æ–∑–∫–∞)")
                                    if success:
                                        self.automation_state = 'waiting_details'
                                        logger.info("‚úÖ –®–∞–≥ 2/3")
                                    return
                    logger.debug("‚è∏Ô∏è –ù–µ—Ç –ø–µ—Ä–µ–≤–æ–∑–æ–∫, –∂–¥—ë–º")

            elif self.automation_state == 'waiting_details':
                logger.info("üì¶ –ò—â—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ...")
                
                if self.last_keyboard:
                    keywords = ['–ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', '–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å', '–≤–∑—è—Ç—å']
                    for row in self.last_keyboard.rows:
                        for button in row.buttons:
                            if isinstance(button, KeyboardButtonCallback):
                                for keyword in keywords:
                                    if keyword in button.text.lower():
                                        logger.info(f"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å: '{button.text}'")
                                        success = await self.click_button(button, "(–ë–†–û–ù–ò–†–û–í–ê–ù–ò–ï)")
                                        if success:
                                            self.automation_state = None
                                            logger.info("üéâ –ó–ê–í–ï–†–®–ï–ù–û!")
                                        return

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            self.automation_state = None

    async def process_new_transport(self, message: Message):
        if self.is_processing:
            logger.warning("‚ö†Ô∏è –£–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è")
            return
        self.is_processing = True
        self.stats['triggers_detected'] += 1
        logger.info("="*60)
        logger.info(f"üö® –ù–û–í–´–ï –ü–ï–†–ï–í–û–ó–ö–ò! (#{self.stats['triggers_detected']})")
        logger.info(f"‚è±Ô∏è {datetime.now().strftime('%H:%M:%S.%f')[:-3]}")
        logger.info("="*60)
        try:
            # –£–±—Ä–∞–Ω–∞ –∑–∞–¥–µ—Ä–∂–∫–∞!
            if self.last_keyboard:
                logger.info("üí® –ë–´–°–¢–†–´–ô —Ä–µ–∂–∏–º!")
                self.automation_state = 'waiting_list'
                self.automation_start_time = datetime.now()
                self.last_processed_state_msg = None
                success = await self.click_buttons_by_strategy()
                if success:
                    logger.info("‚úÖ –®–∞–≥ 1/3")
                else:
                    self.automation_state = None
            else:
                logger.info("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é /start")
                await self.send_start_command()
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            self.stats['errors'] += 1
            self.automation_state = None
        finally:
            self.is_processing = False
            logger.info("="*60)
            self.print_stats()

    async def send_start_command(self):
        if self.bot_entity:
            await self.client.send_message(self.bot_entity, '/start')
            logger.info("üì® /start –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")

    def print_stats(self):
        uptime = datetime.now() - self.stats['start_time']
        logger.info(f"üìä –¢—Ä–∏–≥–≥–µ—Ä–æ–≤:{self.stats['triggers_detected']}, "
                   f"–ö–Ω–æ–ø–æ–∫:{self.stats['buttons_clicked']}, "
                   f"–û—à–∏–±–æ–∫:{self.stats['errors']}, "
                   f"–í—Ä–µ–º—è:{uptime}")

    async def handle_message(self, message):
        if self.bot_entity and message.peer_id.user_id != self.bot_entity.id:
            return
        await self.save_keyboard(message)
        if message.text and TRIGGER_MESSAGE in message.text:
            await self.process_new_transport(message)
            return
        if self.automation_state:
            await self.continue_automation(message)

    async def handle_new_message(self, event):
        await self.handle_message(event.message)

    async def handle_edited_message(self, event):
        logger.debug("üìù Edit")
        await self.handle_message(event.message)

    async def run(self):
        await self.initialize()
        logger.info("="*60)
        logger.info("ü§ñ v4.0 - –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø –°–ö–û–†–û–°–¢–¨")
        logger.info("="*60)
        logger.info(f"üì± –¢—Ä–∏–≥–≥–µ—Ä: '{TRIGGER_MESSAGE}'")
        logger.info(f"‚ö° –ó–∞–¥–µ—Ä–∂–∫–∏: –£–ë–†–ê–ù–´")
        logger.info(f"üí® –ü–æ–º–µ—Ç–∫–∞: –ù–ï–ú–ï–î–õ–ï–ù–ù–ê–Ø")
        logger.info("="*60)
        self.client.add_event_handler(self.handle_new_message, events.NewMessage())
        self.client.add_event_handler(self.handle_edited_message, events.MessageEdited())
        await self.client.run_until_disconnected()

async def main():
    try:
        bot = TransportBookingBot()
        await bot.run()
    except KeyboardInterrupt:
        logger.info("\n" + "="*60)
        logger.info("üëã –û—Å—Ç–∞–Ω–æ–≤–∫–∞...")
        logger.info("="*60)
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")

if __name__ == "__main__":
    asyncio.run(main())
