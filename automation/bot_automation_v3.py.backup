#!/usr/bin/env python3
"""
Telegram Bot Automation –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–µ—Ä–µ–≤–æ–∑–æ–∫
v3: –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–π
"""

import os
import asyncio
import logging
from typing import Optional, List
from datetime import datetime
from dotenv import load_dotenv
from telethon import TelegramClient, events
from telethon.tl.custom import Message
from telethon.tl.types import KeyboardButtonCallback, ReplyInlineMarkup
from telethon.tl import functions
from config import CONFIG

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=getattr(logging, CONFIG.get('LOG_LEVEL', 'INFO'))
)
logger = logging.getLogger(__name__)
logging.getLogger('telethon').setLevel(logging.WARNING)

load_dotenv()

API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
PHONE_NUMBER = os.getenv('PHONE_NUMBER')
BOT_USERNAME = os.getenv('BOT_USERNAME')
SESSION_NAME = os.getenv('SESSION_NAME', 'telegram_session')
TRIGGER_MESSAGE = "–ü–æ—è–≤–∏–ª–∏—Å—å –Ω–æ–≤—ã–µ –ø–µ—Ä–µ–≤–æ–∑–∫–∏"

class TransportBookingBot:
    """–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ø–µ—Ä–µ–≤–æ–∑–æ–∫"""

    def __init__(self):
        self.client = None
        self.bot_entity = None
        self.last_keyboard = None
        self.last_message_id = None
        self.is_processing = False
        
        # State Machine
        self.automation_state = None
        self.automation_start_time = None
        
        # –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –û–ë–†–ê–ë–û–¢–ê–ù–ù–û–ô –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ (message_id + —Å–æ—Å—Ç–æ—è–Ω–∏–µ)
        self.last_processed_state_msg = None
        
        self.stats = {
            'triggers_detected': 0,
            'buttons_clicked': 0,
            'errors': 0,
            'start_time': datetime.now()
        }

    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ Telegram"""
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –∫–ª–∏–µ–Ω—Ç–∞...")
        if not API_ID or not API_HASH:
            raise ValueError("API_ID –∏ API_HASH –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–∫–∞–∑–∞–Ω—ã –≤ .env —Ñ–∞–π–ª–µ")
        self.client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
        await self.client.start(phone=PHONE_NUMBER)
        logger.info("–£—Å–ø–µ—à–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Telegram")
        if BOT_USERNAME:
            try:
                self.bot_entity = await self.client.get_entity(BOT_USERNAME)
                logger.info(f"–ü–æ–¥–∫–ª—é—á–µ–Ω –∫ –±–æ—Ç—É: {BOT_USERNAME}")
            except Exception as e:
                logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –±–æ—Ç–∞ {BOT_USERNAME}: {e}")

    async def save_keyboard(self, message: Message):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã"""
        if message.reply_markup and isinstance(message.reply_markup, ReplyInlineMarkup):
            self.last_keyboard = message.reply_markup
            self.last_message_id = message.id
            if CONFIG.get('LOG_BUTTONS', True):
                logger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å {len(message.reply_markup.rows)} —Ä—è–¥–∞–º–∏ –∫–Ω–æ–ø–æ–∫")
                for row_idx, row in enumerate(message.reply_markup.rows):
                    buttons_text = [btn.text for btn in row.buttons if hasattr(btn, 'text')]
                    logger.debug(f"  –†—è–¥ {row_idx + 1}: {buttons_text}")

    async def find_button_by_keywords(self, keywords: List[str]) -> Optional[tuple]:
        """–ü–æ–∏—Å–∫ –∫–Ω–æ–ø–∫–∏ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º"""
        if not self.last_keyboard:
            return None
        for row_idx, row in enumerate(self.last_keyboard.rows):
            for btn_idx, button in enumerate(row.buttons):
                if isinstance(button, KeyboardButtonCallback) and hasattr(button, 'text'):
                    for keyword in keywords:
                        if keyword.lower() in button.text.lower():
                            return (row_idx, btn_idx, button)
        return None

    async def click_button(self, button: KeyboardButtonCallback, button_info: str = "") -> bool:
        """–ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É"""
        if not self.last_message_id:
            logger.warning("–ù–µ—Ç ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è")
            return False
        try:
            logger.info(f"‚ö° –ù–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É: '{button.text}' {button_info}")
            await self.client(
                functions.messages.GetBotCallbackAnswerRequest(
                    peer=self.bot_entity,
                    msg_id=self.last_message_id,
                    data=button.data
                )
            )
            logger.info(f"‚úì –ö–Ω–æ–ø–∫–∞ '{button.text}' —É—Å–ø–µ—à–Ω–æ –Ω–∞–∂–∞—Ç–∞")
            self.stats['buttons_clicked'] += 1
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏: {e}")
            self.stats['errors'] += 1
            return False

    async def click_buttons_by_strategy(self) -> bool:
        """–ù–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–æ–∫ —Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
        if not self.last_keyboard:
            logger.warning("–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã")
            return False
        strategy = CONFIG.get('BUTTON_STRATEGY', 'first')
        delay = CONFIG.get('DELAY_BETWEEN_CLICKS', 0.1)
        try:
            if strategy == 'first':
                for row_idx, row in enumerate(self.last_keyboard.rows):
                    for btn_idx, button in enumerate(row.buttons):
                        if isinstance(button, KeyboardButtonCallback):
                            return await self.click_button(button, f"(–ø–µ—Ä–≤–∞—è, —Ä—è–¥ {row_idx + 1})")
            elif strategy == 'custom':
                keywords = CONFIG.get('BUTTON_KEYWORDS', [])
                result = await self.find_button_by_keywords(keywords)
                if result:
                    row_idx, btn_idx, button = result
                    return await self.click_button(button, f"(–ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º, —Ä—è–¥ {row_idx + 1})")
                else:
                    logger.warning(f"–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∫–Ω–æ–ø–æ–∫: {keywords}, fallback –Ω–∞ –ø–µ—Ä–≤—É—é")
                    return await self.click_buttons_by_strategy()
            elif strategy == 'all':
                success = False
                for row_idx, row in enumerate(self.last_keyboard.rows):
                    for btn_idx, button in enumerate(row.buttons):
                        if isinstance(button, KeyboardButtonCallback):
                            result = await self.click_button(button, f"(—Ä—è–¥ {row_idx + 1}, –∫–Ω–æ–ø–∫–∞ {btn_idx + 1})")
                            if result:
                                success = True
                                await asyncio.sleep(delay)
                return success
            logger.warning("–ù–µ –Ω–∞–π–¥–µ–Ω–æ callback –∫–Ω–æ–ø–æ–∫")
            return False
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
            self.stats['errors'] += 1
            return False

    async def continue_automation(self, message: Message):
        """–ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –º–Ω–æ–≥–æ—à–∞–≥–æ–≤–æ–π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏"""
        
        # –ö–õ–Æ–ß–ï–í–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–±–∏–Ω–∞—Ü–∏—é (message_id + state)
        state_msg_key = f"{message.id}_{self.automation_state}"
        if self.last_processed_state_msg == state_msg_key:
            logger.debug(f"‚è≠Ô∏è  –ü—Ä–æ–ø—É—Å–∫–∞–µ–º: {state_msg_key} —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω")
            return
        
        logger.info(f"üîÑ –°–æ—Å—Ç–æ—è–Ω–∏–µ: {self.automation_state}, —Å–æ–æ–±—â–µ–Ω–∏–µ: {message.id}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–∞—É—Ç
        if self.automation_start_time:
            elapsed = (datetime.now() - self.automation_start_time).total_seconds()
            if elapsed > 10.0:
                logger.warning("‚è±Ô∏è –¢–∞–π–º–∞—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏")
                self.automation_state = None
                self.last_processed_state_msg = None
                return

        try:
            if self.automation_state == 'waiting_list':
                # –ñ–¥–µ–º —Å–ø–∏—Å–æ–∫ –ø–µ—Ä–µ–≤–æ–∑–æ–∫
                logger.info("üìã –ü–æ–ª—É—á–µ–Ω —Å–ø–∏—Å–æ–∫, –≤—ã–±–∏—Ä–∞—é –ø–µ—Ä–≤—É—é –ø–µ—Ä–µ–≤–æ–∑–∫—É...")
                await asyncio.sleep(0.15)  # –î–∞–µ–º –≤—Ä–µ–º—è —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è
                
                if self.last_keyboard and len(self.last_keyboard.rows) > 0:
                    # –í–ê–ñ–ù–û: –ò—â–µ–º –∫–Ω–æ–ø–∫—É –ü–ï–†–ï–í–û–ó–ö–ò (—Å üöõ), –∞ –Ω–µ –∫–Ω–æ–ø–∫—É –º–µ–Ω—é
                    for row in self.last_keyboard.rows:
                        for button in row.buttons:
                            if isinstance(button, KeyboardButtonCallback):
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –∫–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–≤–æ–∑–∫–∏, –∞ –Ω–µ –º–µ–Ω—é
                                if 'üöõ' in button.text or button.text.replace(' ', '').replace('.', '').isdigit():
                                    logger.info(f"‚ö° –í—ã–±–∏—Ä–∞—é –ø–µ—Ä–µ–≤–æ–∑–∫—É: '{button.text}'")
                                    # –ö–†–ò–¢–ò–ß–ù–û: –ü–æ–º–µ—á–∞–µ–º –î–û –Ω–∞–∂–∞—Ç–∏—è!
                                    self.last_processed_state_msg = state_msg_key
                                    success = await self.click_button(button, "(–ø–µ—Ä–≤–∞—è –ø–µ—Ä–µ–≤–æ–∑–∫–∞)")
                                    if success:
                                        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                                        self.automation_state = 'waiting_details'
                                        logger.info("‚úÖ –®–∞–≥ 2/3: –í—ã–±—Ä–∞–Ω–∞ –ø–µ—Ä–µ–≤–æ–∑–∫–∞")
                                    return
                    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–µ—Ä–µ–≤–æ–∑–∫—É - —ç—Ç–æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π edit, –Ω–µ –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ
                    logger.debug("‚è∏Ô∏è  –ù–µ—Ç –∫–Ω–æ–ø–æ–∫ –ø–µ—Ä–µ–≤–æ–∑–æ–∫, –∂–¥—ë–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ edit")
                    return

            elif self.automation_state == 'waiting_details':
                # –ñ–¥–µ–º –¥–µ—Ç–∞–ª–∏ –ø–µ—Ä–µ–≤–æ–∑–∫–∏
                logger.info("üì¶ –ü–æ–ª—É—á–µ–Ω—ã –¥–µ—Ç–∞–ª–∏, –∏—â—É –∫–Ω–æ–ø–∫—É –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è...")
                await asyncio.sleep(0.15)  # –î–∞–µ–º –≤—Ä–µ–º—è —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è
                
                if self.last_keyboard:
                    keywords = ['–ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å', '–∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å', '–≤–∑—è—Ç—å']
                    for row in self.last_keyboard.rows:
                        for button in row.buttons:
                            if isinstance(button, KeyboardButtonCallback):
                                for keyword in keywords:
                                    if keyword in button.text.lower():
                                        logger.info(f"‚úÖ –ù–∞–∂–∏–º–∞—é: '{button.text}'")
                                        # –ö–†–ò–¢–ò–ß–ù–û: –ü–æ–º–µ—á–∞–µ–º –î–û –Ω–∞–∂–∞—Ç–∏—è!
                                        self.last_processed_state_msg = state_msg_key
                                        success = await self.click_button(button, "(–ë–†–û–ù–ò–†–û–í–ê–ù–ò–ï)")
                                        if success:
                                            self.automation_state = None
                                            logger.info("üéâ –ë–†–û–ù–ò–†–û–í–ê–ù–ò–ï –ó–ê–í–ï–†–®–ï–ù–û!")
                                        return

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏: {e}")
            self.automation_state = None
            self.last_processed_state_msg = None

    async def process_new_transport(self, message: Message):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–∏–≥–≥–µ—Ä–∞"""
        if self.is_processing:
            logger.warning("‚ö†Ô∏è  –£–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
            return
        self.is_processing = True
        self.stats['triggers_detected'] += 1
        logger.info("="*60)
        logger.info(f"üö® –ù–û–í–´–ï –ü–ï–†–ï–í–û–ó–ö–ò! (#{self.stats['triggers_detected']})")
        logger.info(f"‚è±Ô∏è  {datetime.now().strftime('%H:%M:%S.%f')[:-3]}")
        logger.info("="*60)
        try:
            await asyncio.sleep(CONFIG.get('DELAY_AFTER_TRIGGER', 0.05))
            if self.last_keyboard:
                logger.info("üí® –ë–´–°–¢–†–´–ô —Ä–µ–∂–∏–º (cached keyboard)!")
                logger.info("ü§ñ –ó–∞–ø—É—Å–∫ –º–Ω–æ–≥–æ—à–∞–≥–æ–≤–æ–π –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏...")
                self.automation_state = 'waiting_list'
                self.automation_start_time = datetime.now()
                self.last_processed_state_msg = None  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º
                success = await self.click_buttons_by_strategy()
                if success:
                    logger.info("‚úÖ –®–∞–≥ 1/3: –°–ø–∏—Å–æ–∫ –ø–µ—Ä–µ–≤–æ–∑–æ–∫ –æ—Ç–∫—Ä—ã—Ç")
                else:
                    logger.warning("‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫–∏")
                    self.automation_state = None
            else:
                logger.info("üì§ –ù–µ—Ç cached keyboard, –æ—Ç–ø—Ä–∞–≤–ª—è—é /start")
                await self.send_start_command()
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞: {e}")
            self.stats['errors'] += 1
            self.automation_state = None
            self.last_processed_state_msg = None
        finally:
            self.is_processing = False
            logger.info("="*60)
            self.print_stats()

    async def send_start_command(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ /start"""
        if self.bot_entity:
            await self.client.send_message(self.bot_entity, '/start')
            logger.info("üì® /start –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω")

    def print_stats(self):
        """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"""
        uptime = datetime.now() - self.stats['start_time']
        logger.info(f"üìä –¢—Ä–∏–≥–≥–µ—Ä–æ–≤: {self.stats['triggers_detected']}, "
                   f"–ö–Ω–æ–ø–æ–∫: {self.stats['buttons_clicked']}, "
                   f"–û—à–∏–±–æ–∫: {self.stats['errors']}, "
                   f"–í—Ä–µ–º—è: {uptime}")

    async def handle_message(self, message):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        if self.bot_entity and message.peer_id.user_id != self.bot_entity.id:
            return
        await self.save_keyboard(message)
        if message.text and TRIGGER_MESSAGE in message.text:
            await self.process_new_transport(message)
            return
        if self.automation_state:
            await self.continue_automation(message)

    async def handle_new_message(self, event):
        await self.handle_message(event.message)

    async def handle_edited_message(self, event):
        logger.debug("üìù –°–æ–æ–±—â–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ")
        await self.handle_message(event.message)

    async def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        await self.initialize()
        strategy = CONFIG.get('BUTTON_STRATEGY', 'first')
        logger.info("="*60)
        logger.info("ü§ñ Telegram Bot Automation v3 - –ó–ê–ü–£–©–ï–ù")
        logger.info("="*60)
        logger.info(f"üì± –¢—Ä–∏–≥–≥–µ—Ä: '{TRIGGER_MESSAGE}'")
        logger.info(f"‚ö° –°—Ç—Ä–∞—Ç–µ–≥–∏—è: '{strategy}'")
        logger.info(f"üí® –†–µ–∂–∏–º: –ë–´–°–¢–†–´–ô + –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤")
        logger.info("="*60)
        self.client.add_event_handler(self.handle_new_message, events.NewMessage())
        self.client.add_event_handler(self.handle_edited_message, events.MessageEdited())
        await self.client.run_until_disconnected()

async def main():
    try:
        bot = TransportBookingBot()
        await bot.run()
    except KeyboardInterrupt:
        logger.info("\n" + "="*60)
        logger.info("üëã –û—Å—Ç–∞–Ω–æ–≤–∫–∞...")
        logger.info("="*60)
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")

if __name__ == "__main__":
    asyncio.run(main())
